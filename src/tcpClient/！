package tcpClient
import "net"
import "log"
import "tunnel"

const maxBundleClientConns = 0x10
const maxLongConns = 10
const serverAddr = "localhost:9001"



/*test
func (t *tunnel) process(c net.Conn, b *bundle) {
	go t.processClientRead(c, b)
	// process server write
	send := t.send
	for {
		buf, ok := <-send
		if !ok {
			c.close()
			return
		}
		n, err := c.Write(buf)
		if err != nil {
			b.free(t.id)
		} else if n != len(buf) {
			log.Println("Write", n, len(buf))
		}
	}
}

// 初始化channel，并设置long socket, 处理tunnel
func (t *tunnel) open(b *bundle, c net.Conn) {
	t.send = make(chan []byte)
	t.reply = b.xsocket
	go t.process(c, b)
}

func (b *bundle) processConn(c net.Conn) *tunnel {
    // 从空闲列表中拿出一个tunnel来处理新的连接
	b.Lock()
	defer b.Unlock()
	f := b.Front()
	if f == nil {
		return nil
	}
	t := b.Remove(f).(*tunnel)
	t.Element = nil
	// 打开tunnel
	t.open(b, c)
	return t
}
func (b *bundle) get(id int) *tunnel {
	b.Lock()
	defer b.Unlock()
	t := &b.t[id]
	if t.Element != nil {
		return nil
	}
	return t
}
func (b *bundle) free(id int) {
	b.Lock()
	defer b.Unlock()
	t := &b.t[id]
	if t.Element == nil {

	}
}

func newBundle(c net.Conn) *bundle {
	b := new(bundle)
	b.List = list.New()
	for i := 0; i < maxBundleClientConns; i++ {
		t := &b.t[i]
		t.id = i
		t.Element = b.PushBack(t)
	}
	b.xsocket = &xsocket { c, new (sync.Mutex) }
	return b
}

// 处理长连接的读处理，并将数据写入客户端
func processBundle(b *bundle) {

	var header [4]byte
	for {
		_, err := b.Read(header[:])
		if err != nil {
			log.Fatal(err)
		}
		id := 1
		length := 10
		if length == 0 {
			b.free(id)
		} else {
			tunnel := b.get(id)
			buf := make([]byte, length)
			n, err := b.Read(buf)
			if err != nil {
				log.Fatal(err)
			} else if n != len(buf) {

			}

			if tunnel != nil {
				tunnel.send <- buf
			}
		}
	}
}
*/

func processConn (conn net.Conn) {
	log.Println("new connection:", conn.LocalAddr())
	// 选择tunnel
	tunnelId := tunnel.SelectTunnel()
	for {
		buf := make([]byte, 1024)
		length, err := conn.Read(buf)
		if err != nil {
			log.Println("client read error", err)
			break
		}
		// 检查数据处理结果
		rc := tunnel.ProcessData(tunnelId, conn, buf, length, "destination")
		if rc == -1 {
			log.Println("client send err")
			break
		}
	}
}

func initListen(l *tunnel.Listener) {
	// create listener
	listener, err := net.Listen("tcp", "0.0.0.0:9000")
	if err != nil {
		return
	}
	
	// listen and accept connections from clients
	for {
		conn, err := listener.Accept()
		if err != nil {
			return
		}
		// load balance, then process conn
		go processConn(conn)
	}
}


func Run() {
	l := new(tunnel.Listener)

	// init long conns 
	/*for i := 0; i < maxLongConns; i++ {
		addr, err1 := net.ResolveTCPAddr("tcp", serverAddr)
		if err1 != nil {
			log.Fatal(err1)
		}

		conn, err2 := net.DialTCP("tcp", nil, addr)
		if err2 != nil {
			log.Fatal(err2)
		}
		log.Println("i:", i)
		b := newBundle(conn)
		l.bundles[i] = b
		l.id[i] = i
		go processBundle(b)
	}*/
	// 初始化监听，for accept
	initListen(l)
}
